// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'end_of_slot_bundle.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

EndOfSlotBundle _$EndOfSlotBundleFromJson(Map<String, dynamic> json) {
  return _EndOfSlotBundle.fromJson(json);
}

/// @nodoc
mixin _$EndOfSlotBundle {
  ChallengeChainSubSlot get challengeChain =>
      throw _privateConstructorUsedError;
  InfusedChallengeChainSubSlot get infusedChallengeChain =>
      throw _privateConstructorUsedError;
  SubSlotProofs get proofs => throw _privateConstructorUsedError;
  RewardChainSubSlot get rewardChain => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EndOfSlotBundleCopyWith<EndOfSlotBundle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EndOfSlotBundleCopyWith<$Res> {
  factory $EndOfSlotBundleCopyWith(
          EndOfSlotBundle value, $Res Function(EndOfSlotBundle) then) =
      _$EndOfSlotBundleCopyWithImpl<$Res>;
  $Res call(
      {ChallengeChainSubSlot challengeChain,
      InfusedChallengeChainSubSlot infusedChallengeChain,
      SubSlotProofs proofs,
      RewardChainSubSlot rewardChain});

  $ChallengeChainSubSlotCopyWith<$Res> get challengeChain;
  $InfusedChallengeChainSubSlotCopyWith<$Res> get infusedChallengeChain;
  $SubSlotProofsCopyWith<$Res> get proofs;
  $RewardChainSubSlotCopyWith<$Res> get rewardChain;
}

/// @nodoc
class _$EndOfSlotBundleCopyWithImpl<$Res>
    implements $EndOfSlotBundleCopyWith<$Res> {
  _$EndOfSlotBundleCopyWithImpl(this._value, this._then);

  final EndOfSlotBundle _value;
  // ignore: unused_field
  final $Res Function(EndOfSlotBundle) _then;

  @override
  $Res call({
    Object? challengeChain = freezed,
    Object? infusedChallengeChain = freezed,
    Object? proofs = freezed,
    Object? rewardChain = freezed,
  }) {
    return _then(_value.copyWith(
      challengeChain: challengeChain == freezed
          ? _value.challengeChain
          : challengeChain // ignore: cast_nullable_to_non_nullable
              as ChallengeChainSubSlot,
      infusedChallengeChain: infusedChallengeChain == freezed
          ? _value.infusedChallengeChain
          : infusedChallengeChain // ignore: cast_nullable_to_non_nullable
              as InfusedChallengeChainSubSlot,
      proofs: proofs == freezed
          ? _value.proofs
          : proofs // ignore: cast_nullable_to_non_nullable
              as SubSlotProofs,
      rewardChain: rewardChain == freezed
          ? _value.rewardChain
          : rewardChain // ignore: cast_nullable_to_non_nullable
              as RewardChainSubSlot,
    ));
  }

  @override
  $ChallengeChainSubSlotCopyWith<$Res> get challengeChain {
    return $ChallengeChainSubSlotCopyWith<$Res>(_value.challengeChain, (value) {
      return _then(_value.copyWith(challengeChain: value));
    });
  }

  @override
  $InfusedChallengeChainSubSlotCopyWith<$Res> get infusedChallengeChain {
    return $InfusedChallengeChainSubSlotCopyWith<$Res>(
        _value.infusedChallengeChain, (value) {
      return _then(_value.copyWith(infusedChallengeChain: value));
    });
  }

  @override
  $SubSlotProofsCopyWith<$Res> get proofs {
    return $SubSlotProofsCopyWith<$Res>(_value.proofs, (value) {
      return _then(_value.copyWith(proofs: value));
    });
  }

  @override
  $RewardChainSubSlotCopyWith<$Res> get rewardChain {
    return $RewardChainSubSlotCopyWith<$Res>(_value.rewardChain, (value) {
      return _then(_value.copyWith(rewardChain: value));
    });
  }
}

/// @nodoc
abstract class _$$_EndOfSlotBundleCopyWith<$Res>
    implements $EndOfSlotBundleCopyWith<$Res> {
  factory _$$_EndOfSlotBundleCopyWith(
          _$_EndOfSlotBundle value, $Res Function(_$_EndOfSlotBundle) then) =
      __$$_EndOfSlotBundleCopyWithImpl<$Res>;
  @override
  $Res call(
      {ChallengeChainSubSlot challengeChain,
      InfusedChallengeChainSubSlot infusedChallengeChain,
      SubSlotProofs proofs,
      RewardChainSubSlot rewardChain});

  @override
  $ChallengeChainSubSlotCopyWith<$Res> get challengeChain;
  @override
  $InfusedChallengeChainSubSlotCopyWith<$Res> get infusedChallengeChain;
  @override
  $SubSlotProofsCopyWith<$Res> get proofs;
  @override
  $RewardChainSubSlotCopyWith<$Res> get rewardChain;
}

/// @nodoc
class __$$_EndOfSlotBundleCopyWithImpl<$Res>
    extends _$EndOfSlotBundleCopyWithImpl<$Res>
    implements _$$_EndOfSlotBundleCopyWith<$Res> {
  __$$_EndOfSlotBundleCopyWithImpl(
      _$_EndOfSlotBundle _value, $Res Function(_$_EndOfSlotBundle) _then)
      : super(_value, (v) => _then(v as _$_EndOfSlotBundle));

  @override
  _$_EndOfSlotBundle get _value => super._value as _$_EndOfSlotBundle;

  @override
  $Res call({
    Object? challengeChain = freezed,
    Object? infusedChallengeChain = freezed,
    Object? proofs = freezed,
    Object? rewardChain = freezed,
  }) {
    return _then(_$_EndOfSlotBundle(
      challengeChain: challengeChain == freezed
          ? _value.challengeChain
          : challengeChain // ignore: cast_nullable_to_non_nullable
              as ChallengeChainSubSlot,
      infusedChallengeChain: infusedChallengeChain == freezed
          ? _value.infusedChallengeChain
          : infusedChallengeChain // ignore: cast_nullable_to_non_nullable
              as InfusedChallengeChainSubSlot,
      proofs: proofs == freezed
          ? _value.proofs
          : proofs // ignore: cast_nullable_to_non_nullable
              as SubSlotProofs,
      rewardChain: rewardChain == freezed
          ? _value.rewardChain
          : rewardChain // ignore: cast_nullable_to_non_nullable
              as RewardChainSubSlot,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, fieldRename: FieldRename.snake)
class _$_EndOfSlotBundle implements _EndOfSlotBundle {
  const _$_EndOfSlotBundle(
      {required this.challengeChain,
      required this.infusedChallengeChain,
      required this.proofs,
      required this.rewardChain});

  factory _$_EndOfSlotBundle.fromJson(Map<String, dynamic> json) =>
      _$$_EndOfSlotBundleFromJson(json);

  @override
  final ChallengeChainSubSlot challengeChain;
  @override
  final InfusedChallengeChainSubSlot infusedChallengeChain;
  @override
  final SubSlotProofs proofs;
  @override
  final RewardChainSubSlot rewardChain;

  @override
  String toString() {
    return 'EndOfSlotBundle(challengeChain: $challengeChain, infusedChallengeChain: $infusedChallengeChain, proofs: $proofs, rewardChain: $rewardChain)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EndOfSlotBundle &&
            const DeepCollectionEquality()
                .equals(other.challengeChain, challengeChain) &&
            const DeepCollectionEquality()
                .equals(other.infusedChallengeChain, infusedChallengeChain) &&
            const DeepCollectionEquality().equals(other.proofs, proofs) &&
            const DeepCollectionEquality()
                .equals(other.rewardChain, rewardChain));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(challengeChain),
      const DeepCollectionEquality().hash(infusedChallengeChain),
      const DeepCollectionEquality().hash(proofs),
      const DeepCollectionEquality().hash(rewardChain));

  @JsonKey(ignore: true)
  @override
  _$$_EndOfSlotBundleCopyWith<_$_EndOfSlotBundle> get copyWith =>
      __$$_EndOfSlotBundleCopyWithImpl<_$_EndOfSlotBundle>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_EndOfSlotBundleToJson(this);
  }
}

abstract class _EndOfSlotBundle implements EndOfSlotBundle {
  const factory _EndOfSlotBundle(
      {required final ChallengeChainSubSlot challengeChain,
      required final InfusedChallengeChainSubSlot infusedChallengeChain,
      required final SubSlotProofs proofs,
      required final RewardChainSubSlot rewardChain}) = _$_EndOfSlotBundle;

  factory _EndOfSlotBundle.fromJson(Map<String, dynamic> json) =
      _$_EndOfSlotBundle.fromJson;

  @override
  ChallengeChainSubSlot get challengeChain =>
      throw _privateConstructorUsedError;
  @override
  InfusedChallengeChainSubSlot get infusedChallengeChain =>
      throw _privateConstructorUsedError;
  @override
  SubSlotProofs get proofs => throw _privateConstructorUsedError;
  @override
  RewardChainSubSlot get rewardChain => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_EndOfSlotBundleCopyWith<_$_EndOfSlotBundle> get copyWith =>
      throw _privateConstructorUsedError;
}
