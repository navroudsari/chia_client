// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'slots.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ChallengeChainSubSlot _$ChallengeChainSubSlotFromJson(
    Map<String, dynamic> json) {
  return _ChallengeChainSubSlot.fromJson(json);
}

/// @nodoc
mixin _$ChallengeChainSubSlot {
  VDFInfo get challengeChainEndOfSlotVdf => throw _privateConstructorUsedError;
  String? get infusedChallengeChainSubSlotHash =>
      throw _privateConstructorUsedError;
  String? get newDifficulty => throw _privateConstructorUsedError;
  int? get newSubSlotIters => throw _privateConstructorUsedError;
  int? get subepochSummaryHash => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChallengeChainSubSlotCopyWith<ChallengeChainSubSlot> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChallengeChainSubSlotCopyWith<$Res> {
  factory $ChallengeChainSubSlotCopyWith(ChallengeChainSubSlot value,
          $Res Function(ChallengeChainSubSlot) then) =
      _$ChallengeChainSubSlotCopyWithImpl<$Res>;
  $Res call(
      {VDFInfo challengeChainEndOfSlotVdf,
      String? infusedChallengeChainSubSlotHash,
      String? newDifficulty,
      int? newSubSlotIters,
      int? subepochSummaryHash});

  $VDFInfoCopyWith<$Res> get challengeChainEndOfSlotVdf;
}

/// @nodoc
class _$ChallengeChainSubSlotCopyWithImpl<$Res>
    implements $ChallengeChainSubSlotCopyWith<$Res> {
  _$ChallengeChainSubSlotCopyWithImpl(this._value, this._then);

  final ChallengeChainSubSlot _value;
  // ignore: unused_field
  final $Res Function(ChallengeChainSubSlot) _then;

  @override
  $Res call({
    Object? challengeChainEndOfSlotVdf = freezed,
    Object? infusedChallengeChainSubSlotHash = freezed,
    Object? newDifficulty = freezed,
    Object? newSubSlotIters = freezed,
    Object? subepochSummaryHash = freezed,
  }) {
    return _then(_value.copyWith(
      challengeChainEndOfSlotVdf: challengeChainEndOfSlotVdf == freezed
          ? _value.challengeChainEndOfSlotVdf
          : challengeChainEndOfSlotVdf // ignore: cast_nullable_to_non_nullable
              as VDFInfo,
      infusedChallengeChainSubSlotHash: infusedChallengeChainSubSlotHash ==
              freezed
          ? _value.infusedChallengeChainSubSlotHash
          : infusedChallengeChainSubSlotHash // ignore: cast_nullable_to_non_nullable
              as String?,
      newDifficulty: newDifficulty == freezed
          ? _value.newDifficulty
          : newDifficulty // ignore: cast_nullable_to_non_nullable
              as String?,
      newSubSlotIters: newSubSlotIters == freezed
          ? _value.newSubSlotIters
          : newSubSlotIters // ignore: cast_nullable_to_non_nullable
              as int?,
      subepochSummaryHash: subepochSummaryHash == freezed
          ? _value.subepochSummaryHash
          : subepochSummaryHash // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }

  @override
  $VDFInfoCopyWith<$Res> get challengeChainEndOfSlotVdf {
    return $VDFInfoCopyWith<$Res>(_value.challengeChainEndOfSlotVdf, (value) {
      return _then(_value.copyWith(challengeChainEndOfSlotVdf: value));
    });
  }
}

/// @nodoc
abstract class _$$_ChallengeChainSubSlotCopyWith<$Res>
    implements $ChallengeChainSubSlotCopyWith<$Res> {
  factory _$$_ChallengeChainSubSlotCopyWith(_$_ChallengeChainSubSlot value,
          $Res Function(_$_ChallengeChainSubSlot) then) =
      __$$_ChallengeChainSubSlotCopyWithImpl<$Res>;
  @override
  $Res call(
      {VDFInfo challengeChainEndOfSlotVdf,
      String? infusedChallengeChainSubSlotHash,
      String? newDifficulty,
      int? newSubSlotIters,
      int? subepochSummaryHash});

  @override
  $VDFInfoCopyWith<$Res> get challengeChainEndOfSlotVdf;
}

/// @nodoc
class __$$_ChallengeChainSubSlotCopyWithImpl<$Res>
    extends _$ChallengeChainSubSlotCopyWithImpl<$Res>
    implements _$$_ChallengeChainSubSlotCopyWith<$Res> {
  __$$_ChallengeChainSubSlotCopyWithImpl(_$_ChallengeChainSubSlot _value,
      $Res Function(_$_ChallengeChainSubSlot) _then)
      : super(_value, (v) => _then(v as _$_ChallengeChainSubSlot));

  @override
  _$_ChallengeChainSubSlot get _value =>
      super._value as _$_ChallengeChainSubSlot;

  @override
  $Res call({
    Object? challengeChainEndOfSlotVdf = freezed,
    Object? infusedChallengeChainSubSlotHash = freezed,
    Object? newDifficulty = freezed,
    Object? newSubSlotIters = freezed,
    Object? subepochSummaryHash = freezed,
  }) {
    return _then(_$_ChallengeChainSubSlot(
      challengeChainEndOfSlotVdf: challengeChainEndOfSlotVdf == freezed
          ? _value.challengeChainEndOfSlotVdf
          : challengeChainEndOfSlotVdf // ignore: cast_nullable_to_non_nullable
              as VDFInfo,
      infusedChallengeChainSubSlotHash: infusedChallengeChainSubSlotHash ==
              freezed
          ? _value.infusedChallengeChainSubSlotHash
          : infusedChallengeChainSubSlotHash // ignore: cast_nullable_to_non_nullable
              as String?,
      newDifficulty: newDifficulty == freezed
          ? _value.newDifficulty
          : newDifficulty // ignore: cast_nullable_to_non_nullable
              as String?,
      newSubSlotIters: newSubSlotIters == freezed
          ? _value.newSubSlotIters
          : newSubSlotIters // ignore: cast_nullable_to_non_nullable
              as int?,
      subepochSummaryHash: subepochSummaryHash == freezed
          ? _value.subepochSummaryHash
          : subepochSummaryHash // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, fieldRename: FieldRename.snake)
class _$_ChallengeChainSubSlot implements _ChallengeChainSubSlot {
  const _$_ChallengeChainSubSlot(
      {required this.challengeChainEndOfSlotVdf,
      this.infusedChallengeChainSubSlotHash,
      this.newDifficulty,
      this.newSubSlotIters,
      this.subepochSummaryHash});

  factory _$_ChallengeChainSubSlot.fromJson(Map<String, dynamic> json) =>
      _$$_ChallengeChainSubSlotFromJson(json);

  @override
  final VDFInfo challengeChainEndOfSlotVdf;
  @override
  final String? infusedChallengeChainSubSlotHash;
  @override
  final String? newDifficulty;
  @override
  final int? newSubSlotIters;
  @override
  final int? subepochSummaryHash;

  @override
  String toString() {
    return 'ChallengeChainSubSlot(challengeChainEndOfSlotVdf: $challengeChainEndOfSlotVdf, infusedChallengeChainSubSlotHash: $infusedChallengeChainSubSlotHash, newDifficulty: $newDifficulty, newSubSlotIters: $newSubSlotIters, subepochSummaryHash: $subepochSummaryHash)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ChallengeChainSubSlot &&
            const DeepCollectionEquality().equals(
                other.challengeChainEndOfSlotVdf, challengeChainEndOfSlotVdf) &&
            const DeepCollectionEquality().equals(
                other.infusedChallengeChainSubSlotHash,
                infusedChallengeChainSubSlotHash) &&
            const DeepCollectionEquality()
                .equals(other.newDifficulty, newDifficulty) &&
            const DeepCollectionEquality()
                .equals(other.newSubSlotIters, newSubSlotIters) &&
            const DeepCollectionEquality()
                .equals(other.subepochSummaryHash, subepochSummaryHash));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(challengeChainEndOfSlotVdf),
      const DeepCollectionEquality().hash(infusedChallengeChainSubSlotHash),
      const DeepCollectionEquality().hash(newDifficulty),
      const DeepCollectionEquality().hash(newSubSlotIters),
      const DeepCollectionEquality().hash(subepochSummaryHash));

  @JsonKey(ignore: true)
  @override
  _$$_ChallengeChainSubSlotCopyWith<_$_ChallengeChainSubSlot> get copyWith =>
      __$$_ChallengeChainSubSlotCopyWithImpl<_$_ChallengeChainSubSlot>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ChallengeChainSubSlotToJson(this);
  }
}

abstract class _ChallengeChainSubSlot implements ChallengeChainSubSlot {
  const factory _ChallengeChainSubSlot(
      {required final VDFInfo challengeChainEndOfSlotVdf,
      final String? infusedChallengeChainSubSlotHash,
      final String? newDifficulty,
      final int? newSubSlotIters,
      final int? subepochSummaryHash}) = _$_ChallengeChainSubSlot;

  factory _ChallengeChainSubSlot.fromJson(Map<String, dynamic> json) =
      _$_ChallengeChainSubSlot.fromJson;

  @override
  VDFInfo get challengeChainEndOfSlotVdf => throw _privateConstructorUsedError;
  @override
  String? get infusedChallengeChainSubSlotHash =>
      throw _privateConstructorUsedError;
  @override
  String? get newDifficulty => throw _privateConstructorUsedError;
  @override
  int? get newSubSlotIters => throw _privateConstructorUsedError;
  @override
  int? get subepochSummaryHash => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ChallengeChainSubSlotCopyWith<_$_ChallengeChainSubSlot> get copyWith =>
      throw _privateConstructorUsedError;
}

InfusedChallengeChainSubSlot _$InfusedChallengeChainSubSlotFromJson(
    Map<String, dynamic> json) {
  return _InfusedChallengeChainSubSlot.fromJson(json);
}

/// @nodoc
mixin _$InfusedChallengeChainSubSlot {
  VDFInfo get infusedChallengeChainEndOfSlotVdf =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InfusedChallengeChainSubSlotCopyWith<InfusedChallengeChainSubSlot>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InfusedChallengeChainSubSlotCopyWith<$Res> {
  factory $InfusedChallengeChainSubSlotCopyWith(
          InfusedChallengeChainSubSlot value,
          $Res Function(InfusedChallengeChainSubSlot) then) =
      _$InfusedChallengeChainSubSlotCopyWithImpl<$Res>;
  $Res call({VDFInfo infusedChallengeChainEndOfSlotVdf});

  $VDFInfoCopyWith<$Res> get infusedChallengeChainEndOfSlotVdf;
}

/// @nodoc
class _$InfusedChallengeChainSubSlotCopyWithImpl<$Res>
    implements $InfusedChallengeChainSubSlotCopyWith<$Res> {
  _$InfusedChallengeChainSubSlotCopyWithImpl(this._value, this._then);

  final InfusedChallengeChainSubSlot _value;
  // ignore: unused_field
  final $Res Function(InfusedChallengeChainSubSlot) _then;

  @override
  $Res call({
    Object? infusedChallengeChainEndOfSlotVdf = freezed,
  }) {
    return _then(_value.copyWith(
      infusedChallengeChainEndOfSlotVdf: infusedChallengeChainEndOfSlotVdf ==
              freezed
          ? _value.infusedChallengeChainEndOfSlotVdf
          : infusedChallengeChainEndOfSlotVdf // ignore: cast_nullable_to_non_nullable
              as VDFInfo,
    ));
  }

  @override
  $VDFInfoCopyWith<$Res> get infusedChallengeChainEndOfSlotVdf {
    return $VDFInfoCopyWith<$Res>(_value.infusedChallengeChainEndOfSlotVdf,
        (value) {
      return _then(_value.copyWith(infusedChallengeChainEndOfSlotVdf: value));
    });
  }
}

/// @nodoc
abstract class _$$_InfusedChallengeChainSubSlotCopyWith<$Res>
    implements $InfusedChallengeChainSubSlotCopyWith<$Res> {
  factory _$$_InfusedChallengeChainSubSlotCopyWith(
          _$_InfusedChallengeChainSubSlot value,
          $Res Function(_$_InfusedChallengeChainSubSlot) then) =
      __$$_InfusedChallengeChainSubSlotCopyWithImpl<$Res>;
  @override
  $Res call({VDFInfo infusedChallengeChainEndOfSlotVdf});

  @override
  $VDFInfoCopyWith<$Res> get infusedChallengeChainEndOfSlotVdf;
}

/// @nodoc
class __$$_InfusedChallengeChainSubSlotCopyWithImpl<$Res>
    extends _$InfusedChallengeChainSubSlotCopyWithImpl<$Res>
    implements _$$_InfusedChallengeChainSubSlotCopyWith<$Res> {
  __$$_InfusedChallengeChainSubSlotCopyWithImpl(
      _$_InfusedChallengeChainSubSlot _value,
      $Res Function(_$_InfusedChallengeChainSubSlot) _then)
      : super(_value, (v) => _then(v as _$_InfusedChallengeChainSubSlot));

  @override
  _$_InfusedChallengeChainSubSlot get _value =>
      super._value as _$_InfusedChallengeChainSubSlot;

  @override
  $Res call({
    Object? infusedChallengeChainEndOfSlotVdf = freezed,
  }) {
    return _then(_$_InfusedChallengeChainSubSlot(
      infusedChallengeChainEndOfSlotVdf: infusedChallengeChainEndOfSlotVdf ==
              freezed
          ? _value.infusedChallengeChainEndOfSlotVdf
          : infusedChallengeChainEndOfSlotVdf // ignore: cast_nullable_to_non_nullable
              as VDFInfo,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, fieldRename: FieldRename.snake)
class _$_InfusedChallengeChainSubSlot implements _InfusedChallengeChainSubSlot {
  const _$_InfusedChallengeChainSubSlot(
      {required this.infusedChallengeChainEndOfSlotVdf});

  factory _$_InfusedChallengeChainSubSlot.fromJson(Map<String, dynamic> json) =>
      _$$_InfusedChallengeChainSubSlotFromJson(json);

  @override
  final VDFInfo infusedChallengeChainEndOfSlotVdf;

  @override
  String toString() {
    return 'InfusedChallengeChainSubSlot(infusedChallengeChainEndOfSlotVdf: $infusedChallengeChainEndOfSlotVdf)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InfusedChallengeChainSubSlot &&
            const DeepCollectionEquality().equals(
                other.infusedChallengeChainEndOfSlotVdf,
                infusedChallengeChainEndOfSlotVdf));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(infusedChallengeChainEndOfSlotVdf));

  @JsonKey(ignore: true)
  @override
  _$$_InfusedChallengeChainSubSlotCopyWith<_$_InfusedChallengeChainSubSlot>
      get copyWith => __$$_InfusedChallengeChainSubSlotCopyWithImpl<
          _$_InfusedChallengeChainSubSlot>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InfusedChallengeChainSubSlotToJson(this);
  }
}

abstract class _InfusedChallengeChainSubSlot
    implements InfusedChallengeChainSubSlot {
  const factory _InfusedChallengeChainSubSlot(
          {required final VDFInfo infusedChallengeChainEndOfSlotVdf}) =
      _$_InfusedChallengeChainSubSlot;

  factory _InfusedChallengeChainSubSlot.fromJson(Map<String, dynamic> json) =
      _$_InfusedChallengeChainSubSlot.fromJson;

  @override
  VDFInfo get infusedChallengeChainEndOfSlotVdf =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_InfusedChallengeChainSubSlotCopyWith<_$_InfusedChallengeChainSubSlot>
      get copyWith => throw _privateConstructorUsedError;
}

RewardChainSubSlot _$RewardChainSubSlotFromJson(Map<String, dynamic> json) {
  return _RewardChainSubSlot.fromJson(json);
}

/// @nodoc
mixin _$RewardChainSubSlot {
  String get challengeChainSubSlotHash => throw _privateConstructorUsedError;
  int get deficit => throw _privateConstructorUsedError;
  VDFInfo get endOfSlotVdf => throw _privateConstructorUsedError;
  String get infusedChallengeChainSubSlotHash =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RewardChainSubSlotCopyWith<RewardChainSubSlot> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RewardChainSubSlotCopyWith<$Res> {
  factory $RewardChainSubSlotCopyWith(
          RewardChainSubSlot value, $Res Function(RewardChainSubSlot) then) =
      _$RewardChainSubSlotCopyWithImpl<$Res>;
  $Res call(
      {String challengeChainSubSlotHash,
      int deficit,
      VDFInfo endOfSlotVdf,
      String infusedChallengeChainSubSlotHash});

  $VDFInfoCopyWith<$Res> get endOfSlotVdf;
}

/// @nodoc
class _$RewardChainSubSlotCopyWithImpl<$Res>
    implements $RewardChainSubSlotCopyWith<$Res> {
  _$RewardChainSubSlotCopyWithImpl(this._value, this._then);

  final RewardChainSubSlot _value;
  // ignore: unused_field
  final $Res Function(RewardChainSubSlot) _then;

  @override
  $Res call({
    Object? challengeChainSubSlotHash = freezed,
    Object? deficit = freezed,
    Object? endOfSlotVdf = freezed,
    Object? infusedChallengeChainSubSlotHash = freezed,
  }) {
    return _then(_value.copyWith(
      challengeChainSubSlotHash: challengeChainSubSlotHash == freezed
          ? _value.challengeChainSubSlotHash
          : challengeChainSubSlotHash // ignore: cast_nullable_to_non_nullable
              as String,
      deficit: deficit == freezed
          ? _value.deficit
          : deficit // ignore: cast_nullable_to_non_nullable
              as int,
      endOfSlotVdf: endOfSlotVdf == freezed
          ? _value.endOfSlotVdf
          : endOfSlotVdf // ignore: cast_nullable_to_non_nullable
              as VDFInfo,
      infusedChallengeChainSubSlotHash: infusedChallengeChainSubSlotHash ==
              freezed
          ? _value.infusedChallengeChainSubSlotHash
          : infusedChallengeChainSubSlotHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $VDFInfoCopyWith<$Res> get endOfSlotVdf {
    return $VDFInfoCopyWith<$Res>(_value.endOfSlotVdf, (value) {
      return _then(_value.copyWith(endOfSlotVdf: value));
    });
  }
}

/// @nodoc
abstract class _$$_RewardChainSubSlotCopyWith<$Res>
    implements $RewardChainSubSlotCopyWith<$Res> {
  factory _$$_RewardChainSubSlotCopyWith(_$_RewardChainSubSlot value,
          $Res Function(_$_RewardChainSubSlot) then) =
      __$$_RewardChainSubSlotCopyWithImpl<$Res>;
  @override
  $Res call(
      {String challengeChainSubSlotHash,
      int deficit,
      VDFInfo endOfSlotVdf,
      String infusedChallengeChainSubSlotHash});

  @override
  $VDFInfoCopyWith<$Res> get endOfSlotVdf;
}

/// @nodoc
class __$$_RewardChainSubSlotCopyWithImpl<$Res>
    extends _$RewardChainSubSlotCopyWithImpl<$Res>
    implements _$$_RewardChainSubSlotCopyWith<$Res> {
  __$$_RewardChainSubSlotCopyWithImpl(
      _$_RewardChainSubSlot _value, $Res Function(_$_RewardChainSubSlot) _then)
      : super(_value, (v) => _then(v as _$_RewardChainSubSlot));

  @override
  _$_RewardChainSubSlot get _value => super._value as _$_RewardChainSubSlot;

  @override
  $Res call({
    Object? challengeChainSubSlotHash = freezed,
    Object? deficit = freezed,
    Object? endOfSlotVdf = freezed,
    Object? infusedChallengeChainSubSlotHash = freezed,
  }) {
    return _then(_$_RewardChainSubSlot(
      challengeChainSubSlotHash: challengeChainSubSlotHash == freezed
          ? _value.challengeChainSubSlotHash
          : challengeChainSubSlotHash // ignore: cast_nullable_to_non_nullable
              as String,
      deficit: deficit == freezed
          ? _value.deficit
          : deficit // ignore: cast_nullable_to_non_nullable
              as int,
      endOfSlotVdf: endOfSlotVdf == freezed
          ? _value.endOfSlotVdf
          : endOfSlotVdf // ignore: cast_nullable_to_non_nullable
              as VDFInfo,
      infusedChallengeChainSubSlotHash: infusedChallengeChainSubSlotHash ==
              freezed
          ? _value.infusedChallengeChainSubSlotHash
          : infusedChallengeChainSubSlotHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, fieldRename: FieldRename.snake)
class _$_RewardChainSubSlot implements _RewardChainSubSlot {
  const _$_RewardChainSubSlot(
      {required this.challengeChainSubSlotHash,
      required this.deficit,
      required this.endOfSlotVdf,
      required this.infusedChallengeChainSubSlotHash});

  factory _$_RewardChainSubSlot.fromJson(Map<String, dynamic> json) =>
      _$$_RewardChainSubSlotFromJson(json);

  @override
  final String challengeChainSubSlotHash;
  @override
  final int deficit;
  @override
  final VDFInfo endOfSlotVdf;
  @override
  final String infusedChallengeChainSubSlotHash;

  @override
  String toString() {
    return 'RewardChainSubSlot(challengeChainSubSlotHash: $challengeChainSubSlotHash, deficit: $deficit, endOfSlotVdf: $endOfSlotVdf, infusedChallengeChainSubSlotHash: $infusedChallengeChainSubSlotHash)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RewardChainSubSlot &&
            const DeepCollectionEquality().equals(
                other.challengeChainSubSlotHash, challengeChainSubSlotHash) &&
            const DeepCollectionEquality().equals(other.deficit, deficit) &&
            const DeepCollectionEquality()
                .equals(other.endOfSlotVdf, endOfSlotVdf) &&
            const DeepCollectionEquality().equals(
                other.infusedChallengeChainSubSlotHash,
                infusedChallengeChainSubSlotHash));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(challengeChainSubSlotHash),
      const DeepCollectionEquality().hash(deficit),
      const DeepCollectionEquality().hash(endOfSlotVdf),
      const DeepCollectionEquality().hash(infusedChallengeChainSubSlotHash));

  @JsonKey(ignore: true)
  @override
  _$$_RewardChainSubSlotCopyWith<_$_RewardChainSubSlot> get copyWith =>
      __$$_RewardChainSubSlotCopyWithImpl<_$_RewardChainSubSlot>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RewardChainSubSlotToJson(this);
  }
}

abstract class _RewardChainSubSlot implements RewardChainSubSlot {
  const factory _RewardChainSubSlot(
          {required final String challengeChainSubSlotHash,
          required final int deficit,
          required final VDFInfo endOfSlotVdf,
          required final String infusedChallengeChainSubSlotHash}) =
      _$_RewardChainSubSlot;

  factory _RewardChainSubSlot.fromJson(Map<String, dynamic> json) =
      _$_RewardChainSubSlot.fromJson;

  @override
  String get challengeChainSubSlotHash => throw _privateConstructorUsedError;
  @override
  int get deficit => throw _privateConstructorUsedError;
  @override
  VDFInfo get endOfSlotVdf => throw _privateConstructorUsedError;
  @override
  String get infusedChallengeChainSubSlotHash =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_RewardChainSubSlotCopyWith<_$_RewardChainSubSlot> get copyWith =>
      throw _privateConstructorUsedError;
}

SubSlotProofs _$SubSlotProofsFromJson(Map<String, dynamic> json) {
  return _SubSlotProofs.fromJson(json);
}

/// @nodoc
mixin _$SubSlotProofs {
  VDFProof get challengeChainSlotProof => throw _privateConstructorUsedError;
  VDFProof get infusedChallengeChainSlotProof =>
      throw _privateConstructorUsedError;
  VDFProof get rewardChainSlotProof => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubSlotProofsCopyWith<SubSlotProofs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubSlotProofsCopyWith<$Res> {
  factory $SubSlotProofsCopyWith(
          SubSlotProofs value, $Res Function(SubSlotProofs) then) =
      _$SubSlotProofsCopyWithImpl<$Res>;
  $Res call(
      {VDFProof challengeChainSlotProof,
      VDFProof infusedChallengeChainSlotProof,
      VDFProof rewardChainSlotProof});

  $VDFProofCopyWith<$Res> get challengeChainSlotProof;
  $VDFProofCopyWith<$Res> get infusedChallengeChainSlotProof;
  $VDFProofCopyWith<$Res> get rewardChainSlotProof;
}

/// @nodoc
class _$SubSlotProofsCopyWithImpl<$Res>
    implements $SubSlotProofsCopyWith<$Res> {
  _$SubSlotProofsCopyWithImpl(this._value, this._then);

  final SubSlotProofs _value;
  // ignore: unused_field
  final $Res Function(SubSlotProofs) _then;

  @override
  $Res call({
    Object? challengeChainSlotProof = freezed,
    Object? infusedChallengeChainSlotProof = freezed,
    Object? rewardChainSlotProof = freezed,
  }) {
    return _then(_value.copyWith(
      challengeChainSlotProof: challengeChainSlotProof == freezed
          ? _value.challengeChainSlotProof
          : challengeChainSlotProof // ignore: cast_nullable_to_non_nullable
              as VDFProof,
      infusedChallengeChainSlotProof: infusedChallengeChainSlotProof == freezed
          ? _value.infusedChallengeChainSlotProof
          : infusedChallengeChainSlotProof // ignore: cast_nullable_to_non_nullable
              as VDFProof,
      rewardChainSlotProof: rewardChainSlotProof == freezed
          ? _value.rewardChainSlotProof
          : rewardChainSlotProof // ignore: cast_nullable_to_non_nullable
              as VDFProof,
    ));
  }

  @override
  $VDFProofCopyWith<$Res> get challengeChainSlotProof {
    return $VDFProofCopyWith<$Res>(_value.challengeChainSlotProof, (value) {
      return _then(_value.copyWith(challengeChainSlotProof: value));
    });
  }

  @override
  $VDFProofCopyWith<$Res> get infusedChallengeChainSlotProof {
    return $VDFProofCopyWith<$Res>(_value.infusedChallengeChainSlotProof,
        (value) {
      return _then(_value.copyWith(infusedChallengeChainSlotProof: value));
    });
  }

  @override
  $VDFProofCopyWith<$Res> get rewardChainSlotProof {
    return $VDFProofCopyWith<$Res>(_value.rewardChainSlotProof, (value) {
      return _then(_value.copyWith(rewardChainSlotProof: value));
    });
  }
}

/// @nodoc
abstract class _$$_SubSlotProofsCopyWith<$Res>
    implements $SubSlotProofsCopyWith<$Res> {
  factory _$$_SubSlotProofsCopyWith(
          _$_SubSlotProofs value, $Res Function(_$_SubSlotProofs) then) =
      __$$_SubSlotProofsCopyWithImpl<$Res>;
  @override
  $Res call(
      {VDFProof challengeChainSlotProof,
      VDFProof infusedChallengeChainSlotProof,
      VDFProof rewardChainSlotProof});

  @override
  $VDFProofCopyWith<$Res> get challengeChainSlotProof;
  @override
  $VDFProofCopyWith<$Res> get infusedChallengeChainSlotProof;
  @override
  $VDFProofCopyWith<$Res> get rewardChainSlotProof;
}

/// @nodoc
class __$$_SubSlotProofsCopyWithImpl<$Res>
    extends _$SubSlotProofsCopyWithImpl<$Res>
    implements _$$_SubSlotProofsCopyWith<$Res> {
  __$$_SubSlotProofsCopyWithImpl(
      _$_SubSlotProofs _value, $Res Function(_$_SubSlotProofs) _then)
      : super(_value, (v) => _then(v as _$_SubSlotProofs));

  @override
  _$_SubSlotProofs get _value => super._value as _$_SubSlotProofs;

  @override
  $Res call({
    Object? challengeChainSlotProof = freezed,
    Object? infusedChallengeChainSlotProof = freezed,
    Object? rewardChainSlotProof = freezed,
  }) {
    return _then(_$_SubSlotProofs(
      challengeChainSlotProof: challengeChainSlotProof == freezed
          ? _value.challengeChainSlotProof
          : challengeChainSlotProof // ignore: cast_nullable_to_non_nullable
              as VDFProof,
      infusedChallengeChainSlotProof: infusedChallengeChainSlotProof == freezed
          ? _value.infusedChallengeChainSlotProof
          : infusedChallengeChainSlotProof // ignore: cast_nullable_to_non_nullable
              as VDFProof,
      rewardChainSlotProof: rewardChainSlotProof == freezed
          ? _value.rewardChainSlotProof
          : rewardChainSlotProof // ignore: cast_nullable_to_non_nullable
              as VDFProof,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, fieldRename: FieldRename.snake)
class _$_SubSlotProofs implements _SubSlotProofs {
  const _$_SubSlotProofs(
      {required this.challengeChainSlotProof,
      required this.infusedChallengeChainSlotProof,
      required this.rewardChainSlotProof});

  factory _$_SubSlotProofs.fromJson(Map<String, dynamic> json) =>
      _$$_SubSlotProofsFromJson(json);

  @override
  final VDFProof challengeChainSlotProof;
  @override
  final VDFProof infusedChallengeChainSlotProof;
  @override
  final VDFProof rewardChainSlotProof;

  @override
  String toString() {
    return 'SubSlotProofs(challengeChainSlotProof: $challengeChainSlotProof, infusedChallengeChainSlotProof: $infusedChallengeChainSlotProof, rewardChainSlotProof: $rewardChainSlotProof)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubSlotProofs &&
            const DeepCollectionEquality().equals(
                other.challengeChainSlotProof, challengeChainSlotProof) &&
            const DeepCollectionEquality().equals(
                other.infusedChallengeChainSlotProof,
                infusedChallengeChainSlotProof) &&
            const DeepCollectionEquality()
                .equals(other.rewardChainSlotProof, rewardChainSlotProof));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(challengeChainSlotProof),
      const DeepCollectionEquality().hash(infusedChallengeChainSlotProof),
      const DeepCollectionEquality().hash(rewardChainSlotProof));

  @JsonKey(ignore: true)
  @override
  _$$_SubSlotProofsCopyWith<_$_SubSlotProofs> get copyWith =>
      __$$_SubSlotProofsCopyWithImpl<_$_SubSlotProofs>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubSlotProofsToJson(this);
  }
}

abstract class _SubSlotProofs implements SubSlotProofs {
  const factory _SubSlotProofs(
      {required final VDFProof challengeChainSlotProof,
      required final VDFProof infusedChallengeChainSlotProof,
      required final VDFProof rewardChainSlotProof}) = _$_SubSlotProofs;

  factory _SubSlotProofs.fromJson(Map<String, dynamic> json) =
      _$_SubSlotProofs.fromJson;

  @override
  VDFProof get challengeChainSlotProof => throw _privateConstructorUsedError;
  @override
  VDFProof get infusedChallengeChainSlotProof =>
      throw _privateConstructorUsedError;
  @override
  VDFProof get rewardChainSlotProof => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_SubSlotProofsCopyWith<_$_SubSlotProofs> get copyWith =>
      throw _privateConstructorUsedError;
}
